#ifndef MAZE_H
#define MAZE_H

#include "byul_config.h"
#include "internal/coord.h"
#include "internal/coord_hash.h"
#include "internal/map.h"
#include "internal/maze_common.h"

#ifdef __cplusplus
extern "C" {
#endif

// ë¯¸ë¡œ ì•Œê³ ë¦¬ì¦˜ íƒ€ì…
typedef enum {
    MAZE_TYPE_RECURSIVE,
    MAZE_TYPE_PRIM,
    MAZE_TYPE_BINARY,
    MAZE_TYPE_ELLER,
    MAZE_TYPE_ALDOUS_BRODER,
    MAZE_TYPE_WILSON,
    MAZE_TYPE_HUNT_AND_KILL,
    MAZE_TYPE_SIDEWINDER,
    MAZE_TYPE_RECURSIVE_DIVISION,
    MAZE_TYPE_KRUSKAL,
    MAZE_TYPE_ROOM_BLEND
} maze_type_t;

BYUL_API void maze_make(maze_t* maze, maze_type_t type);

/**
 * @brief ì¬ê·€ì  ë¶„í• (Recursive Division) ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ë¯¸ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * ì´ í•¨ìˆ˜ëŠ” ì£¼ì–´ì§„ `maze_t` êµ¬ì¡°ì²´ ë‚´ ì •ì˜ëœ ì˜ì—­(
 * `x0`, `y0`, `width`, `height`)ì„ ê¸°ë°˜ìœ¼ë¡œ,
 * ê³ ì „ì ì¸ **ì¬ê·€ì  ë¶„í•  ì•Œê³ ë¦¬ì¦˜**ì„ í†µí•´ ë²½ê³¼ í†µë¡œì˜ êµ¬ì¡°ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 * ë‚´ë¶€ì ìœ¼ë¡œ 2ì…€ ë‹¨ìœ„ë¡œ ë²½ê³¼ í†µë¡œë¥¼ ë°˜ë³µì ìœ¼ë¡œ ë‚˜ëˆ„ë©°,
 * ë°˜ë“œì‹œ í™€ìˆ˜ í¬ê¸°ì˜ ë„ˆë¹„ì™€ ë†’ì´(ì˜ˆ: 9x9)ë¥¼ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ê¶Œì¥ë©ë‹ˆë‹¤.
 *
 * - ìƒì„±ëœ ê²°ê³¼ëŠ” `maze->blocked` ë‚´ë¶€ì— ì €ì¥ë˜ë©°,
 *   `maze_apply_to_map()` í•¨ìˆ˜ë¥¼ í†µí•´ `map_t`ì— ì‚½ì…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 * - ì´ í•¨ìˆ˜ëŠ” `maze_t` êµ¬ì¡°ì²´ì˜ `type` í•„ë“œê°€ 
 * `MAZE_TYPE_RECURSIVE`ì¼ ë•Œì—ë§Œ í˜¸ì¶œë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
 * - ë¯¸ë¡œì˜ ì¢Œí‘œê³„ëŠ” ì ˆëŒ€ ì¢Œí‘œ ê¸°ì¤€ì´ë©°, `x0`, `y0`ëŠ” ë¯¸ë¡œ ì¢Œì¸¡ ìƒë‹¨ ê¸°ì¤€ì ì…ë‹ˆë‹¤.
 *
 * @note 4ë°©í–¥(ìƒ,í•˜,ì¢Œ,ìš°) ê¸°ì¤€ìœ¼ë¡œë§Œ ë¶„í• ë˜ë©°, ëŒ€ê°ì„  ì—°ê²°ì€ ìƒì„±ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
 * @note ë¯¸ë¡œëŠ” ì™¸ë²½ì´ ë§‰í˜€ ìˆëŠ” í˜•íƒœë¡œ ìƒì„±ë˜ë©°, ì¶œì…êµ¬ëŠ” ë”°ë¡œ ëš«ì–´ì•¼ í•©ë‹ˆë‹¤.
 *
 * @param maze ë¯¸ë¡œ ì •ë³´ì™€ ê²°ê³¼ê°€ ì €ì¥ë  `maze_t*` í¬ì¸í„°
 *
 * @see maze_new_full()
 * @see maze_apply_to_map()
 */
BYUL_API void maze_make_recursive(maze_t* maze);

/**
 * @brief Prim ì•Œê³ ë¦¬ì¦˜ì„ ì´ìš©í•˜ì—¬ ë¯¸ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * ì´ í•¨ìˆ˜ëŠ” ì§€ì •ëœ maze_t êµ¬ì¡°ì²´ ë‚´ë¶€ì— Prim ì•Œê³ ë¦¬ì¦˜ ê¸°ë°˜ì˜
 * ë¯¸ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤. ìƒì„±ëœ ë¯¸ë¡œëŠ” ë‚´ë¶€ blocked ì¢Œí‘œ ì§‘í•©ì— ê¸°ë¡ë˜ë©°,
 * í•„ìš” ì‹œ `maze_apply_to_map()` í•¨ìˆ˜ë¥¼ í†µí•´ map_tì— ì‚½ì…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 *
 * @details
 * Prim ì•Œê³ ë¦¬ì¦˜ì€ ê·¸ë˜í”„ ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬(MST)ë¥¼ êµ¬í•˜ëŠ” ë°©ì‹ì—ì„œ
 * ì‘ìš©ëœ ë¯¸ë¡œ ìƒì„± ë°©ë²•ì…ë‹ˆë‹¤. ë²½ìœ¼ë¡œ ë‘˜ëŸ¬ì‹¸ì¸ ì…€ë“¤ ì¤‘ í•˜ë‚˜ì—ì„œ ì‹œì‘í•˜ì—¬,
 * ì¸ì ‘í•œ ë²½ì„ ëœë¤í•˜ê²Œ ì„ íƒí•˜ë©´ì„œ ì…€ë“¤ì„ ì—°ê²°í•´ ë‚˜ê°‘ë‹ˆë‹¤.
 * ì´ë•Œ í•œìª½ ì…€ë§Œ ë°©ë¬¸ëœ ìƒíƒœì¸ ë²½ë§Œ ì„ íƒí•˜ë©°, ì „ì²´ë¥¼ í•˜ë‚˜ì˜ ì—°ê²°ëœ í†µë¡œë¡œ ë§Œë“­ë‹ˆë‹¤.
 *
 * ë¯¸ë¡œëŠ” í™€ìˆ˜ í¬ê¸°(width, height)ë¡œ êµ¬ì„±í•˜ëŠ” ê²ƒì´ ì¼ë°˜ì ì´ë©°,
 * ëª¨ë“  ì…€ì€ í™€ìˆ˜ ì¢Œí‘œì— ìœ„ì¹˜í•˜ë©°, ê·¸ ì‚¬ì´ì˜ ì§ìˆ˜ ì¢Œí‘œëŠ” ë²½ìœ¼ë¡œ ê°„ì£¼ë©ë‹ˆë‹¤.
 *
 * @usage
 * ```c
 * maze_t* maze = maze_new_full(0, 0, 21, 21, MAZE_TYPE_PRIM);
 * maze_make_prim(maze);
 * map_t* map = map_new_full(21, 21, MAP_NEIGHBOR_4, NULL);
 * maze_apply_to_map(maze, map);
 * // ì´í›„ map ì‚¬ìš©
 * maze_free(maze);
 * map_free(map);
 * ```
 *
 * @param maze ë¯¸ë¡œë¥¼ ìƒì„±í•  maze_t í¬ì¸í„° (NULL ë¶ˆê°€)
 */
BYUL_API void maze_make_prim(maze_t* maze);

/**
 * @brief Binary Tree ì•Œê³ ë¦¬ì¦˜ìœ¼ë¡œ ë¯¸ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * ì´ í•¨ìˆ˜ëŠ” Binary Tree ë°©ì‹ì˜ ë¯¸ë¡œ ìƒì„± ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬
 * ì£¼ì–´ì§„ `maze_t` êµ¬ì¡°ì²´ ë‚´ë¶€ì˜ `blocked` ì¢Œí‘œ ì§‘í•©ì„ ì„¤ì •í•©ë‹ˆë‹¤.
 *
 * Binary Tree ì•Œê³ ë¦¬ì¦˜ì€ ê° ì…€ì—ì„œ ë¶ìª½ ë˜ëŠ” ë™ìª½ìœ¼ë¡œë§Œ 
 * ë²½ì„ í—ˆë¬¼ì–´ê°€ëŠ” ë§¤ìš° ë‹¨ìˆœí•œ ë°©ì‹ì´ë©°,
 * êµ¬í˜„ì´ ê°„ë‹¨í•˜ê³  ë¹ ë¥´ì§€ë§Œ, ìƒì„±ë˜ëŠ” ë¯¸ë¡œëŠ” í¸í–¥ëœ ê²½í–¥ì´ ìˆìŠµë‹ˆë‹¤.
 *
 * - í•­ìƒ ì˜¤ë¥¸ìª½ ë˜ëŠ” ì•„ë˜ ë°©í–¥ í†µë¡œê°€ ì¡´ì¬í•˜ê²Œ ë˜ì–´ ë³µì¡ë„ê°€ ë‚®ìŠµë‹ˆë‹¤.
 * - ê·œì¹™ì„±ì´ ê°•í•˜ë¯€ë¡œ, ì‹¤ì œ ê²Œì„ì—ì„œëŠ” ë³´ì¡° ì•Œê³ ë¦¬ì¦˜ì´ë‚˜ í›„ì²˜ë¦¬ê°€ í•„ìš”í•œ ê²½ìš°ê°€ ë§ìŠµë‹ˆë‹¤.
 *
 * @param maze ë¯¸ë¡œì˜ ì¢Œí‘œ ê¸°ì¤€, ë„ˆë¹„, ë†’ì´, 
 *      íƒ€ì…(MAZE_TYPE_BINARY)ì´ ì„¤ì •ëœ êµ¬ì¡°ì²´ í¬ì¸í„°ì…ë‹ˆë‹¤.
 *             ì´ í•¨ìˆ˜ëŠ” í•´ë‹¹ êµ¬ì¡°ì²´ ë‚´ë¶€ì˜ blocked í•„ë“œë¥¼ ìˆ˜ì •í•˜ì—¬ ë¯¸ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * @note `maze`ëŠ” ë°˜ë“œì‹œ ìœ íš¨í•œ í¬ì¸í„°ì—¬ì•¼ í•˜ë©°, 
 *       `width`ì™€ `height`ëŠ” í™€ìˆ˜ë¡œ ì„¤ì •ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
 *       (ë¯¸ë¡œ ë²½ê³¼ í†µë¡œë¥¼ êµ¬ë¶„í•˜ê¸° ìœ„í•¨ì…ë‹ˆë‹¤.)
 *
 * @see maze_new_full()
 * @see maze_apply_to_map()
 *
 * @example
 * ```c
 * maze_t* maze = maze_new_full(0, 0, 9, 9, MAZE_TYPE_BINARY);
 * maze_make_binary(maze);
 * map_t* map = map_new();
 * maze_apply_to_map(maze, map);
 * ```
 */
BYUL_API void maze_make_binary(maze_t* maze);

/**
 * @brief Eller ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ë¯¸ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * ì´ í•¨ìˆ˜ëŠ” ê³ ì „ì ì¸ **Eller ì•Œê³ ë¦¬ì¦˜**ì„ ê¸°ë°˜ìœ¼ë¡œ, ì§€ì •ëœ `maze_t` êµ¬ì¡°ì²´ ë‚´ë¶€ì—
 * ë¯¸ë¡œ íŒ¨í„´ì„ ìƒì„±í•©ë‹ˆë‹¤. ë¯¸ë¡œëŠ” **í•œ ì¤„ì”©(row-by-row)** ìƒì„±ë˜ë©°, ê° ì¤„ë§ˆë‹¤
 * ì…‹(set) IDë¥¼ ê´€ë¦¬í•˜ê³  ë³‘í•©í•˜ë©° ë‹¤ìŒ ì¤„ë¡œ ì—°ê²°í•˜ì—¬ ì „ì²´ ì—°ê²°ëœ êµ¬ì¡°ë¥¼ ë§Œë“­ë‹ˆë‹¤.
 *
 * ### ì•Œê³ ë¦¬ì¦˜ ê°œìš”
 * - ê° í™€ìˆ˜ ì¹¸ë§ˆë‹¤ ê³ ìœ í•œ ì…‹(set) IDë¥¼ ë¶€ì—¬í•©ë‹ˆë‹¤.
 * - ì¢Œìš° ì¸ì ‘ ì…€ì„ ëœë¤í•˜ê²Œ ë³‘í•©(ì—°ê²°)í•˜ì—¬ ìˆ˜í‰ í†µë¡œë¥¼ ë§Œë“­ë‹ˆë‹¤.
 * - ê° ì…‹ë§ˆë‹¤ ìµœì†Œ í•˜ë‚˜ ì´ìƒì€ ì•„ë˜ìª½ìœ¼ë¡œ ì—°ê²°ë˜ë„ë¡ ìˆ˜ì§ í†µë¡œë¥¼ ê°œë°©í•©ë‹ˆë‹¤.
 * - ë§ˆì§€ë§‰ ì¤„ì—ì„œëŠ” ë‚¨ì€ ì…‹ì„ ì „ë¶€ ë³‘í•©í•˜ì—¬ í•˜ë‚˜ì˜ ì—°ê²°ëœ êµ¬ì¡°ë¥¼ ì™„ì„±í•©ë‹ˆë‹¤.
 *
 * > â— ì´ ì•Œê³ ë¦¬ì¦˜ì€ **ì™¸ê³½ ë²½ì„ ê°•ì œí•˜ì§€ ì•Šìœ¼ë©°**,  
 * > ì™¸ë¶€ì—ì„œ í›„ì²˜ë¦¬ë¡œ ë²½ì„ ì¶”ê°€í•´ì•¼ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.  
 * > ì•Œê³ ë¦¬ì¦˜ ì›ë¦¬ì— ì¶©ì‹¤í•˜ê²Œ êµ¬í˜„ë˜ì–´ ìˆìœ¼ë©°, 
 *      ì™¸ê³½ ê°œë°© ì—¬ë¶€ë„ ë¬´ì‘ìœ„ì— ë”°ë¼ ë‹¬ë¼ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 *
 * ### ì‚¬ìš© ì¡°ê±´
 * ì´ í•¨ìˆ˜ëŠ” ë°˜ë“œì‹œ `maze_new_full()` 
 *      í•¨ìˆ˜ë¥¼ í†µí•´ ìƒì„±ëœ `maze_t` êµ¬ì¡°ì²´ë¥¼ ì‚¬ìš©í•´ì•¼ í•˜ë©°,  
 * ë‹¤ìŒê³¼ ê°™ì€ ì œì•½ì„ ë§Œì¡±í•´ì•¼ í•©ë‹ˆë‹¤:
 * - ê°€ë¡œ(width)ì™€ ì„¸ë¡œ(height)ëŠ” **í™€ìˆ˜ ê°’**ì´ì–´ì•¼ í•©ë‹ˆë‹¤. (ì˜ˆ: 9x9, 11x7)
 * - ê°€ë¡œ, ì„¸ë¡œëŠ” ìµœì†Œ **3 ì´ìƒ**ì´ì–´ì•¼ í•©ë‹ˆë‹¤.
 *
 * ### ì‚¬ìš© ì˜ˆì‹œ
 * @code
 * maze_t* maze = maze_new_full(0, 0, 9, 9, MAZE_TYPE_ELLER);
 * maze_make_eller(maze);
 * map_add_maze(map, maze);
 * @endcode
 *
 * í•¨ìˆ˜ ì‹¤í–‰ í›„ `maze->blocked` í•„ë“œì—ëŠ” ë²½ ì¢Œí‘œê°€ ë“±ë¡ë˜ë©°,  
 * `maze->type` í•„ë“œëŠ” `MAZE_TYPE_ELLER`ë¡œ ì„¤ì •ë©ë‹ˆë‹¤.
 *
 * @param maze ë¯¸ë¡œ ë°ì´í„°ë¥¼ ìƒì„±í•  maze_t í¬ì¸í„°
 */
BYUL_API void maze_make_eller(maze_t* maze);

/**
 * @brief Aldous-Broder ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ë¯¸ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * ì´ í•¨ìˆ˜ëŠ” **Aldous-Broder ì•Œê³ ë¦¬ì¦˜**ì„ ì‚¬ìš©í•˜ì—¬ ì§€ì •ëœ `maze_t` êµ¬ì¡°ì²´ì—  
 * ë¬´ì‘ìœ„ ìˆœíšŒ ê¸°ë°˜(Random Walk) ë°©ì‹ìœ¼ë¡œ ë¯¸ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.  
 * ëª¨ë“  ì…€ì„ ë¬´ì‘ìœ„ë¡œ ìˆœíšŒí•˜ë©´ì„œ, **ë°©ë¬¸í•˜ì§€ ì•Šì€ ì…€ì— ë„ë‹¬í–ˆì„ ë•Œë§Œ í†µë¡œë¥¼ ê°œë°©**í•©ë‹ˆë‹¤.
 *
 * ### ì•Œê³ ë¦¬ì¦˜ ê°œìš”
 * - ë¬´ì‘ìœ„ ì…€ì—ì„œ ì‹œì‘í•˜ì—¬ ê³„ì†í•´ì„œ ì´ì›ƒ ì…€ë¡œ ì´ë™í•©ë‹ˆë‹¤.
 * - **ë°©ë¬¸í•˜ì§€ ì•Šì€ ì…€ì„ ì²˜ìŒ ë°©ë¬¸í–ˆì„ ë•Œ**, 
 *      í˜„ì¬ ìœ„ì¹˜ì™€ ë‹¤ìŒ ì…€ ì‚¬ì´ì— **í†µë¡œë¥¼ ê°œë°©**í•©ë‹ˆë‹¤.
 * - ì´ë¯¸ ë°©ë¬¸í•œ ì…€ë¡œ ì´ë™í•˜ëŠ” ê²½ìš°ëŠ” í†µë¡œë¥¼ ë§Œë“¤ì§€ ì•Šê³  ê·¸ëŒ€ë¡œ ì´ë™ë§Œ í•©ë‹ˆë‹¤.
 * - ëª¨ë“  ì…€ì´ ë°©ë¬¸ë  ë•Œê¹Œì§€ ë°˜ë³µí•˜ë©°, ì´ë¥¼ í†µí•´ ì™„ì „í•œ ì—°ê²°ì„±ì„ ê°–ì¶˜ ë¯¸ë¡œë¥¼ ë§Œë“­ë‹ˆë‹¤.
 *
 * ì´ ì•Œê³ ë¦¬ì¦˜ì€ ë§¤ìš° ë‹¨ìˆœí•˜ë©´ì„œë„,
 * **ëª¨ë“  ê°€ëŠ¥í•œ ë¯¸ë¡œ ì¤‘ í•˜ë‚˜ë¥¼ ê· ì¼í•œ í™•ë¥ ë¡œ ìƒì„±í•˜ëŠ” ìœ ì¼í•œ ì•Œê³ ë¦¬ì¦˜** ì¤‘ í•˜ë‚˜ì…ë‹ˆë‹¤.
 *
 * > â— ë‹¨ì : í‰ê· ì ìœ¼ë¡œ ë§¤ìš° ë¹„íš¨ìœ¨ì ì¼ ìˆ˜ ìˆìœ¼ë©°,  
 * > íŠ¹íˆ ì…€ ê°œìˆ˜ê°€ ë§ì„ìˆ˜ë¡ ì‹œê°„ì´ ì˜¤ë˜ ê±¸ë¦´ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 *
 * > â— ì™¸ê³½ ë²½ì€ ì•Œê³ ë¦¬ì¦˜ ë‚´ë¶€ì—ì„œ ê°•ì œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.  
 * > í•„ìš”í•˜ë‹¤ë©´ `maze_make()` ë˜ëŠ” í›„ì²˜ë¦¬ ë‹¨ê³„ì—ì„œ ë³„ë„ë¡œ ì²˜ë¦¬í•˜ì„¸ìš”.
 *
 * ---
 *
 * ### ì‚¬ìš© ì¡°ê±´
 * - `maze_t`ëŠ” ë°˜ë“œì‹œ `maze_new_full()` í•¨ìˆ˜ë¥¼ í†µí•´ ìƒì„±ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
 * - ê°€ë¡œ(`width`)ì™€ ì„¸ë¡œ(`height`)ëŠ” **í™€ìˆ˜**ì—¬ì•¼ í•˜ë©°, **ìµœì†Œ 3 ì´ìƒ**ì´ì–´ì•¼ í•©ë‹ˆë‹¤.
 *
 * ### ì‚¬ìš© ì˜ˆì‹œ
 * @code
 * maze_t* maze = maze_new_full(0, 0, 9, 9, MAZE_TYPE_ALDOUS_BRODER);
 * maze_make_aldous_broder(maze);
 * map_add_maze(map, maze);
 * @endcode
 *
 * í•¨ìˆ˜ ì‹¤í–‰ì´ ì™„ë£Œë˜ë©´ `maze->blocked`ì— ë²½ ì¢Œí‘œê°€ ì‚½ì…ë˜ê³ ,  
 * `maze->type`ì€ `MAZE_TYPE_ALDOUS_BRODER`ë¡œ ì„¤ì •ë©ë‹ˆë‹¤.
 *
 * @param maze ë¯¸ë¡œë¥¼ ìƒì„±í•  ëŒ€ìƒ maze_t í¬ì¸í„°
 */
BYUL_API void maze_make_aldous_broder(maze_t* maze);

/**
 * @brief Wilson ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ë¯¸ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * ì´ í•¨ìˆ˜ëŠ” **Wilson ì•Œê³ ë¦¬ì¦˜(Wilson's Algorithm)**ì„ ì‚¬ìš©í•˜ì—¬  
 * ì™„ì „í•œ ì—°ê²°ì„±ì„ ê°€ì§€ë©°, **í¸í–¥ ì—†ëŠ”(uniform)** ë¯¸ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.  
 * ì•Œê³ ë¦¬ì¦˜ì˜ í•µì‹¬ì€ **Loop-Erased Random Walk (LERW)** ë°©ì‹ìœ¼ë¡œ,  
 * ì¤‘ë³µ ê²½ë¡œë¥¼ ì œê±°í•˜ë©´ì„œ ìˆœìˆ˜í•œ íŠ¸ë¦¬ í˜•íƒœì˜ ë¯¸ë¡œë¥¼ êµ¬ì„±í•©ë‹ˆë‹¤.
 *
 * ### ì•Œê³ ë¦¬ì¦˜ ê°œìš”
 * - ëª¨ë“  ì…€ ì¤‘ í•˜ë‚˜ë¥¼ **ê¸°ì´ˆ ì…€(initial cell)**ë¡œ ì„¤ì •í•˜ê³  ë°©ë¬¸ ì²˜ë¦¬í•©ë‹ˆë‹¤.
 * - ë‚˜ë¨¸ì§€ ë°©ë¬¸í•˜ì§€ ì•Šì€ ì…€ë“¤ ì¤‘ í•˜ë‚˜ë¥¼ ë¬´ì‘ìœ„ë¡œ ì„ íƒí•˜ì—¬ **ë¬´ì‘ìœ„ ìˆœíšŒ**ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.
 * - ì´ë¯¸ ë°©ë¬¸í•œ ì…€ì— ë„ë‹¬í•  ë•Œê¹Œì§€ ì´ë™í•˜ë©°, 
 *      ì¤‘ê°„ì— **ë£¨í”„ê°€ ìƒê¸°ë©´ ì œê±°(loop erase)**í•©ë‹ˆë‹¤.
 * - ìµœì¢…ì ìœ¼ë¡œ ì–»ì–´ì§„ ê²½ë¡œë¥¼ ë¯¸ë¡œì— **í†µë¡œ(PASSAGE)**ë¡œ ë°˜ì˜í•˜ê³ , ë°©ë¬¸ ì²˜ë¦¬í•©ë‹ˆë‹¤.
 * - ì´ ê³¼ì •ì„ **ëª¨ë“  ì…€ì´ í¬í•¨ë  ë•Œê¹Œì§€ ë°˜ë³µ**í•˜ì—¬ í•˜ë‚˜ì˜ 
 *      ì™„ì „í•œ spanning treeë¥¼ ë§Œë“­ë‹ˆë‹¤.
 *
 * > ğŸ“Œ ì´ ì•Œê³ ë¦¬ì¦˜ì€ ì´ë¡ ì ìœ¼ë¡œ **ê°€ì¥ ê³µì •í•œ(ê· ë“± ë¶„í¬)** ë¯¸ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 * > ë‹¨ì ì€ ì†ë„ê°€ ëŠë¦´ ìˆ˜ ìˆê³ , ë³µì¡í•œ êµ¬í˜„ì´ í•„ìš”í•˜ë‹¤ëŠ” ì ì…ë‹ˆë‹¤.
 *
 * ---
 *
 * ### ì‚¬ìš© ì¡°ê±´
 * - `maze_t`ëŠ” ë°˜ë“œì‹œ `maze_new_full()` í•¨ìˆ˜ë¥¼ í†µí•´ ìƒì„±ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
 * - ê°€ë¡œ(`width`)ì™€ ì„¸ë¡œ(`height`)ëŠ” ë°˜ë“œì‹œ **í™€ìˆ˜ ê°’**ì´ì–´ì•¼ í•˜ë©°, 
 *      **3 ì´ìƒ**ì´ì–´ì•¼ í•©ë‹ˆë‹¤.
 *
 * ### ì™¸ê³½ ë²½ ì²˜ë¦¬
 * - ì´ ì•Œê³ ë¦¬ì¦˜ì€ ì™¸ê³½ì„ ë²½ìœ¼ë¡œ ê°•ì œí•˜ì§€ ì•Šìœ¼ë©°,  
 *   í•„ìš”í•˜ë‹¤ë©´ `maze_make()` ë˜ëŠ” í›„ì²˜ë¦¬ ë‹¨ê³„ì—ì„œ ì™¸ê³½ ë²½ì„ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤.
 *
 * ### ì‚¬ìš© ì˜ˆì‹œ
 * @code
 * maze_t* maze = maze_new_full(0, 0, 9, 9, MAZE_TYPE_WILSON);
 * maze_make_wilson(maze);
 * map_add_maze(map, maze);
 * @endcode
 *
 * í•¨ìˆ˜ í˜¸ì¶œì´ ì™„ë£Œë˜ë©´ `maze->blocked`ì— ë²½ ì¢Œí‘œê°€ ê¸°ë¡ë˜ê³ ,  
 * `maze->type` í•„ë“œëŠ” `MAZE_TYPE_WILSON`ìœ¼ë¡œ ì„¤ì •ë©ë‹ˆë‹¤.
 *
 * @param maze ë¯¸ë¡œë¥¼ ìƒì„±í•  ëŒ€ìƒ maze_t í¬ì¸í„°
 */
BYUL_API void maze_make_wilson(maze_t* maze);

/**
 * @brief Hunt-and-Kill ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ë¯¸ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * ì´ í•¨ìˆ˜ëŠ” **Hunt-and-Kill ì•Œê³ ë¦¬ì¦˜**ì„ ê¸°ë°˜ìœ¼ë¡œ ì§€ì •ëœ `maze_t` êµ¬ì¡°ì²´ì—  
 * ê¹Šì´ ì—†ëŠ” ëœë¤ ì›Œí¬ ë°©ì‹ì˜ ë¯¸ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.  
 * DFS(ê¹Šì´ ìš°ì„  íƒìƒ‰)ë³´ë‹¤ ê°„ë‹¨í•˜ë©°, 
 *      ìì—°ìŠ¤ëŸ¬ìš´ **íŠ¸ë¦¬ í˜•íƒœì˜ ë¯¸ë¡œ**ë¥¼ ë¹ ë¥´ê²Œ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
 *
 * ### ì•Œê³ ë¦¬ì¦˜ ê°œìš”
 * - **Kill Phase**: ë¬´ì‘ìœ„ë¡œ ë°©í–¥ì„ ì„ íƒí•˜ì—¬ ë°©ë¬¸í•˜ì§€ ì•Šì€ 
 *      ì´ì›ƒì´ ìˆë‹¤ë©´ í†µë¡œë¥¼ ëš«ê³  ì´ë™í•©ë‹ˆë‹¤.
 * - ì´ì›ƒì´ ì—†ë‹¤ë©´ íƒìƒ‰ì„ ì¢…ë£Œí•˜ê³ , ë‹¤ìŒ ë‹¨ê³„ë¡œ ë„˜ì–´ê°‘ë‹ˆë‹¤.
 *
 * - **Hunt Phase**: ì „ì²´ ì…€ì„ ìˆœíšŒí•˜ë©°  
 *   ì•„ì§ ë°©ë¬¸ë˜ì§€ ì•Šì•˜ì§€ë§Œ **ì¸ì ‘í•œ ë°©ë¬¸ ì…€ì´ ì¡´ì¬í•˜ëŠ” ì…€**ì„ ì°¾ìŠµë‹ˆë‹¤.  
 *   í•´ë‹¹ ì…€ê³¼ ì—°ê²°ëœ ë°©í–¥ìœ¼ë¡œ í†µë¡œë¥¼ ëš«ê³  ë‹¤ì‹œ Kill Phaseë¡œ ì§„ì…í•©ë‹ˆë‹¤.
 *
 * ì´ ê³¼ì •ì„ **ëª¨ë“  ì…€ì´ ë°©ë¬¸ë  ë•Œê¹Œì§€ ë°˜ë³µ**í•˜ë©°,  
 * ê²°ê³¼ì ìœ¼ë¡œ í•˜ë‚˜ì˜ ì—°ê²°ëœ íŠ¸ë¦¬ í˜•íƒœì˜ ë¯¸ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * > â— ì´ ì•Œê³ ë¦¬ì¦˜ì€ êµ¬í˜„ì´ ê°„ë‹¨í•˜ê³  ë¹ ë¥´ë©°,  
 * > Dead-endê°€ ë§ì€ ì „í˜•ì ì¸ ë‚˜ë¬´ êµ¬ì¡°ì˜ ë¯¸ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * > â— ì™¸ê³½ ë²½ì€ ì•Œê³ ë¦¬ì¦˜ ë‚´ë¶€ì—ì„œ ê°•ì œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.  
 * > í•„ìš”í•œ ê²½ìš° ì™¸ë¶€ì—ì„œ í›„ì²˜ë¦¬ë¡œ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤.
 *
 * ---
 *
 * ### ì‚¬ìš© ì¡°ê±´
 * - `maze_t`ëŠ” ë°˜ë“œì‹œ `maze_new_full()` í•¨ìˆ˜ë¥¼ í†µí•´ ìƒì„±ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
 * - ê°€ë¡œ(`width`)ì™€ ì„¸ë¡œ(`height`)ëŠ” **í™€ìˆ˜ ê°’**ì´ì–´ì•¼ í•˜ë©°, **3 ì´ìƒ**ì´ì–´ì•¼ í•©ë‹ˆë‹¤.
 *
 * ### ì‚¬ìš© ì˜ˆì‹œ
 * @code
 * maze_t* maze = maze_new_full(0, 0, 9, 9, MAZE_TYPE_HUNT_AND_KILL);
 * maze_make_hunt_and_kill(maze);
 * map_add_maze(map, maze);
 * @endcode
 *
 * í•¨ìˆ˜ í˜¸ì¶œì´ ì™„ë£Œë˜ë©´ `maze->blocked` í•„ë“œì—ëŠ” ë²½ ì¢Œí‘œê°€ ê¸°ë¡ë˜ê³ ,  
 * `maze->type` í•„ë“œëŠ” `MAZE_TYPE_HUNT_AND_KILL`ìœ¼ë¡œ ì„¤ì •ë©ë‹ˆë‹¤.
 *
 * @param maze ë¯¸ë¡œë¥¼ ìƒì„±í•  ëŒ€ìƒ maze_t í¬ì¸í„°
 */
BYUL_API void maze_make_hunt_and_kill(maze_t* maze);

/**
 * @brief Sidewinder ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ë¯¸ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * ì´ í•¨ìˆ˜ëŠ” **Sidewinder ì•Œê³ ë¦¬ì¦˜**ì„ ê¸°ë°˜ìœ¼ë¡œ,  
 * ì˜¤ë¥¸ìª½ ë°©í–¥ ì¤‘ì‹¬ì˜ í†µë¡œ êµ¬ì¡°ë¥¼ ê°€ì§„ ë¯¸ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.  
 * Binary Tree ì•Œê³ ë¦¬ì¦˜ì„ ìˆ˜í‰ ë°©í–¥ìœ¼ë¡œ í™•ì¥í•œ êµ¬ì¡°ì´ë©°,  
 * ê¸´ ê°€ë¡œ í†µë¡œì™€ ì ì€ ìˆ˜ì§ ì—°ê²°ë¡œ ì¸í•´ **ì—´ë¦° ëŠë‚Œì˜ ë¯¸ë¡œ**ê°€ ë§Œë“¤ì–´ì§‘ë‹ˆë‹¤.
 *
 * ### ì•Œê³ ë¦¬ì¦˜ ê°œìš”
 * - ë¯¸ë¡œë¥¼ **ìœ„ì—ì„œ ì•„ë˜ë¡œ ì¤„ ë‹¨ìœ„(row-by-row)**ë¡œ ì²˜ë¦¬í•©ë‹ˆë‹¤.
 * - ê° ì¤„ë§ˆë‹¤ **run set**ì„ ìœ ì§€í•˜ë©´ì„œ ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì—°ê²°í• ì§€ ë¬´ì‘ìœ„ë¡œ ê²°ì •í•©ë‹ˆë‹¤.
 * - ì˜¤ë¥¸ìª½ìœ¼ë¡œ ì—°ê²°í•˜ì§€ ì•Šê¸°ë¡œ ê²°ì •ë˜ë©´,  
 *   run setì—ì„œ í•˜ë‚˜ë¥¼ ì„ íƒí•´ **ìœ„ìª½ìœ¼ë¡œ ì—°ê²°**í•˜ê³  runì„ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
 * - ì´ ê³¼ì •ì„ ëª¨ë“  ì¤„ì— ëŒ€í•´ ë°˜ë³µí•©ë‹ˆë‹¤.
 *
 * > â— ì´ ì•Œê³ ë¦¬ì¦˜ì€ ì‚¬ì´í´ì´ ì—†ëŠ” íŠ¸ë¦¬ êµ¬ì¡°ë¥¼ ë³´ì¥í•˜ë©°,  
 * > **Dead-endê°€ ê±°ì˜ ì—†ëŠ” ë¶€ë“œëŸ¬ìš´ ë¯¸ë¡œ**ë¥¼ ë¹ ë¥´ê²Œ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * > â— ì™¸ê³½ ë²½ì€ ì•Œê³ ë¦¬ì¦˜ ë‚´ë¶€ì—ì„œ ê°•ì œí•˜ì§€ ì•Šìœ¼ë¯€ë¡œ,  
 * > í•„ìš”í•  ê²½ìš° ì™¸ë¶€ì—ì„œ í›„ì²˜ë¦¬ë¡œ ì¶”ê°€í•´ì•¼ í•©ë‹ˆë‹¤.
 *
 * ---
 *
 * ### ì‚¬ìš© ì¡°ê±´
 * - `maze_t`ëŠ” ë°˜ë“œì‹œ `maze_new_full()` í•¨ìˆ˜ë¥¼ í†µí•´ ìƒì„±ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
 * - ê°€ë¡œ(`width`)ì™€ ì„¸ë¡œ(`height`)ëŠ” **í™€ìˆ˜ ê°’**ì´ì–´ì•¼ í•˜ë©°, **3 ì´ìƒ**ì´ì–´ì•¼ í•©ë‹ˆë‹¤.
 *
 * ### ì‚¬ìš© ì˜ˆì‹œ
 * @code
 * maze_t* maze = maze_new_full(0, 0, 9, 9, MAZE_TYPE_SIDEWINDER);
 * maze_make_sidewinder(maze);
 * map_add_maze(map, maze);
 * @endcode
 *
 * í•¨ìˆ˜ í˜¸ì¶œì´ ì™„ë£Œë˜ë©´ `maze->blocked` í•„ë“œì—ëŠ” ë²½ ì¢Œí‘œê°€ ê¸°ë¡ë˜ë©°,  
 * `maze->type`ì€ `MAZE_TYPE_SIDEWINDER`ë¡œ ì„¤ì •ë©ë‹ˆë‹¤.
 *
 * @param maze ë¯¸ë¡œë¥¼ ìƒì„±í•  ëŒ€ìƒ maze_t í¬ì¸í„°
 */
BYUL_API void maze_make_sidewinder(maze_t* maze);

/**
 * @brief Recursive Division ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ë¯¸ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * ì´ í•¨ìˆ˜ëŠ” **Recursive Division (ì¬ê·€ì  ë¶„í• )** ì•Œê³ ë¦¬ì¦˜ì„ ê¸°ë°˜ìœ¼ë¡œ  
 * ë¯¸ë¡œ ê³µê°„ì„ ë²½ìœ¼ë¡œ ë‚˜ëˆ„ë©°, ê° ì˜ì—­ì— ë¬´ì‘ìœ„ë¡œ í†µë¡œë¥¼ ë§Œë“¤ì–´  
 * ì •ëˆëœ ê±´ì¶•ì  êµ¬ì¡°ì˜ ë¯¸ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * ### ğŸ”¹ ì•Œê³ ë¦¬ì¦˜ ê°œìš”
 * - ë¯¸ë¡œ ì „ì²´ ê³µê°„ì„ ê¸°ì¤€ìœ¼ë¡œ ë¬´ì‘ìœ„ ë°©í–¥(ê°€ë¡œ ë˜ëŠ” ì„¸ë¡œ)ì˜ ë²½ì„ ì„¸ì›ë‹ˆë‹¤.
 * - í•´ë‹¹ ë²½ì—ëŠ” **í†µë¡œë¥¼ í•˜ë‚˜ ë¬´ì‘ìœ„ ìœ„ì¹˜ì— ìƒì„±**í•©ë‹ˆë‹¤.
 * - ë²½ì„ ê¸°ì¤€ìœ¼ë¡œ ë‚˜ë‰œ ë‘ ì˜ì—­ì— ëŒ€í•´ **ì¬ê·€ì ìœ¼ë¡œ ê°™ì€ ê³¼ì •ì„ ë°˜ë³µ**í•©ë‹ˆë‹¤.
 * - ì˜ì—­ í¬ê¸°ê°€ ì¶©ë¶„íˆ ì‘ì•„ì§€ë©´ ë¶„í• ì„ ì¤‘ë‹¨í•©ë‹ˆë‹¤.
 *
 * ### âš ï¸ ì¤‘ìš”í•œ íŠ¹ì„±
 * - ì´ ì•Œê³ ë¦¬ì¦˜ì€ **íŠ¸ë¦¬ ê¸°ë°˜ êµ¬ì¡°ê°€ ì•„ë‹ˆë©°**,  
 *   **Dead-end(ë§‰ë‹¤ë¥¸ ê¸¸)ê°€ ê±°ì˜ ì—†ëŠ” ê°œë°©í˜• êµ¬ì¡°**ê°€ ë©ë‹ˆë‹¤.
 * - ë˜í•œ **ê¸¸ì˜ ì—°ê²°ì´ ë³´ì¥ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.**
 *   â†’ ì—°ê²°ë˜ì§€ ì•Šì€ ë°©ì´ë‚˜ ë³µë„ê°€ ì¡´ì¬í•  ìˆ˜ ìˆìœ¼ë©°,  
 *   ì´ë¥¼ í•´ê²°í•˜ë ¤ë©´ ë³„ë„ì˜ í›„ì²˜ë¦¬(`fix_disconnected_regions()` ë“±)ê°€ í•„ìš”í•©ë‹ˆë‹¤.
 *
 * > ğŸ”§ ë”°ë¼ì„œ, íƒìƒ‰ ê°€ëŠ¥í•œ ë‹¨ì¼ ê²½ë¡œë§ì´ í•„ìš”í•œ ê²½ìš°ì—ëŠ”  
 * > `MAZE_TYPE_PRIM`, `MAZE_TYPE_KRUSKAL` ë“± 
 *      íŠ¸ë¦¬ ê¸°ë°˜ ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ ì ì ˆí•©ë‹ˆë‹¤.
 *
 * ---
 *
 * ### ì‚¬ìš© ì¡°ê±´
 * - `maze_t`ëŠ” ë°˜ë“œì‹œ `maze_new_full()`ë¡œ ìƒì„±ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
 * - `width` ë° `height`ëŠ” **í™€ìˆ˜ì´ë©° 3 ì´ìƒ**ì´ì–´ì•¼ í•©ë‹ˆë‹¤.
 *
 * ### ì‚¬ìš© ì˜ˆì‹œ
 * @code
 * maze_t* maze = maze_new_full(0, 0, 9, 9, MAZE_TYPE_RECURSIVE_DIVISION);
 * maze_make_recursive_division(maze);
 * map_add_maze(map, maze);
 * @endcode
 *
 * í•¨ìˆ˜ ì‹¤í–‰ í›„:
 * - `maze->blocked` í•„ë“œì— ë²½ ì¢Œí‘œê°€ ê¸°ë¡ë©ë‹ˆë‹¤.
 * - `maze->type`ì€ `MAZE_TYPE_RECURSIVE_DIVISION`ìœ¼ë¡œ ì„¤ì •ë©ë‹ˆë‹¤.
 *
 * @param maze ë¯¸ë¡œë¥¼ ìƒì„±í•  ëŒ€ìƒ maze_t í¬ì¸í„°
 */
BYUL_API void maze_make_recursive_division(maze_t* maze);

/**
 * @brief Kruskal ì•Œê³ ë¦¬ì¦˜ì„ ì‚¬ìš©í•˜ì—¬ ì™„ì „ ì—°ê²°ëœ ë¯¸ë¡œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * ì´ í•¨ìˆ˜ëŠ” **Kruskalâ€™s Algorithm (í¬ëŸ¬ìŠ¤ì»¬ ì•Œê³ ë¦¬ì¦˜)**ì„ ê¸°ë°˜ìœ¼ë¡œ  
 * ìµœì†Œ ì‹ ì¥ íŠ¸ë¦¬(MST)ë¥¼ êµ¬ì„±í•˜ì—¬ **ì‚¬ì´í´ì´ ì—†ëŠ” ì™„ì „í•œ ë¯¸ë¡œ**ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.  
 * ê° í†µë¡œ ì…€ì€ **ì„œë¡œ ë‹¤ë¥¸ ì§‘í•©**ìœ¼ë¡œ ì‹œì‘í•˜ë©°,  
 * ì¸ì ‘í•œ ì…€ì„ ì‡ëŠ” ë²½ë“¤ì„ ë¬´ì‘ìœ„ ìˆœì„œë¡œ ì²˜ë¦¬í•˜ë©°  
 * **ë‘ ì…€ì´ ë‹¤ë¥¸ ì§‘í•©ì¼ ê²½ìš° ë²½ì„ í—ˆë¬¼ê³  ë³‘í•©**í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì‘ë™í•©ë‹ˆë‹¤.
 *
 * ### ğŸ”¹ ì•Œê³ ë¦¬ì¦˜ ê°œìš”
 * - ëª¨ë“  í™€ìˆ˜ ì¢Œí‘œ ì…€ì„ PASSAGEë¡œ ì´ˆê¸°í™”í•˜ê³ , ê°ê° ë³„ë„ ì§‘í•©ìœ¼ë¡œ ì§€ì •í•©ë‹ˆë‹¤.
 * - ì¸ì ‘í•œ ì…€ ì‚¬ì´ì˜ ë²½ì„ ê°„ì„ ìœ¼ë¡œ ê°„ì£¼í•˜ì—¬ ë¦¬ìŠ¤íŠ¸ì— ì €ì¥í•©ë‹ˆë‹¤.
 * - ì´ ë²½ ë¦¬ìŠ¤íŠ¸ë¥¼ **ë¬´ì‘ìœ„ë¡œ ì„ì€ í›„**, í•œ ë²½ì”© ì„ íƒí•˜ë©´ì„œ:
 *   - ë²½ ì–‘ìª½ ì…€ì´ ì„œë¡œ ë‹¤ë¥¸ ì§‘í•©ì´ë©´ â†’ ë²½ì„ ì œê±°í•˜ê³  ë³‘í•©(union)
 *   - ê°™ì€ ì§‘í•©ì´ë©´ â†’ ë¬´ì‹œ
 * - ëª¨ë“  ì…€ì´ í•˜ë‚˜ì˜ ì§‘í•©ìœ¼ë¡œ ë³‘í•©ë˜ë©´ ì¢…ë£Œë©ë‹ˆë‹¤.
 *
 * > âœ… ì´ ì•Œê³ ë¦¬ì¦˜ì€ í•­ìƒ **ëª¨ë“  ì…€ì´ í•˜ë‚˜ì˜ ê²½ë¡œë§ìœ¼ë¡œ ì—°ê²°**ë˜ëŠ”  
 * > **ì—°ê²° ë³´ì¥í˜• ë¯¸ë¡œ**ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
 *
 * > âœ… ì‚¬ì´í´ì´ ì¡´ì¬í•˜ì§€ ì•Šìœ¼ë©°, **Dead-endê°€ í’ë¶€í•œ íŠ¸ë¦¬ êµ¬ì¡°**ê°€ í˜•ì„±ë©ë‹ˆë‹¤.
 *
 * ---
 *
 * ### ì‚¬ìš© ì¡°ê±´
 * - `maze_t`ëŠ” ë°˜ë“œì‹œ `maze_new_full()`ë¡œ ìƒì„±ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
 * - `width`, `height`ëŠ” **í™€ìˆ˜ì´ë©´ì„œ 3 ì´ìƒ**ì´ì–´ì•¼ í•©ë‹ˆë‹¤.
 *
 * ### ì‚¬ìš© ì˜ˆì‹œ
 * @code
 * maze_t* maze = maze_new_full(0, 0, 9, 9, MAZE_TYPE_KRUSKAL);
 * maze_make_kruskal(maze);
 * map_add_maze(map, maze);
 * @endcode
 *
 * í•¨ìˆ˜ ì‹¤í–‰ì´ ì™„ë£Œë˜ë©´:
 * - `maze->blocked` í•„ë“œì— ë²½ ì¢Œí‘œê°€ ì €ì¥ë©ë‹ˆë‹¤.
 * - `maze->type`ì€ `MAZE_TYPE_KRUSKAL`ë¡œ ì„¤ì •ë©ë‹ˆë‹¤.
 *
 * @param maze ë¯¸ë¡œë¥¼ ìƒì„±í•  ëŒ€ìƒ maze_t í¬ì¸í„°
 */
BYUL_API void maze_make_kruskal(maze_t* maze);

#ifdef __cplusplus
}
#endif

#endif // MAZE_H
